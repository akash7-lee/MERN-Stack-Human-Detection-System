{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { concat } from '../concat';\nimport { fill } from '../fill';\nimport { op } from '../operation';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { tensor2d } from '../tensor2d';\n/**\n * Expands input into frames of frameLength.\n * Slides a window size with frameStep.\n *\n * ```js\n * tf.signal.frame([1, 2, 3], 2, 1).print();\n * ```\n * @param signal The input tensor to be expanded\n * @param frameLength Length of each frame\n * @param frameStep The frame hop size in samples.\n * @param padEnd Whether to pad the end of signal with padValue.\n * @param padValue A number to use where the input signal does\n *     not exist when padEnd is True.\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction frame_(signal, frameLength, frameStep) {\n  let padEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let padValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let start = 0;\n  const output = [];\n  while (start + frameLength <= signal.size) {\n    output.push(slice(signal, start, frameLength));\n    start += frameStep;\n  }\n  if (padEnd) {\n    while (start < signal.size) {\n      const padLen = start + frameLength - signal.size;\n      const pad = concat([slice(signal, start, frameLength - padLen), fill([padLen], padValue)]);\n      output.push(pad);\n      start += frameStep;\n    }\n  }\n  if (output.length === 0) {\n    return tensor2d([], [0, frameLength]);\n  }\n  return reshape(concat(output), [output.length, frameLength]);\n}\nexport const frame = /* @__PURE__ */op({\n  frame_\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zaWduYWwvZnJhbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBQzdCLE9BQU8sRUFBQyxFQUFFLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDaEMsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNuQyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQy9CLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFFckM7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsU0FBUyxNQUFNLENBQ1gsTUFBZ0IsRUFBRSxXQUFtQixFQUFFLFNBQWlCLEVBQUUsTUFBTSxHQUFHLEtBQUssRUFDeEUsUUFBUSxHQUFHLENBQUM7SUFDZCxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxNQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7SUFDNUIsT0FBTyxLQUFLLEdBQUcsV0FBVyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUU7UUFDekMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQy9DLEtBQUssSUFBSSxTQUFTLENBQUM7S0FDcEI7SUFFRCxJQUFJLE1BQU0sRUFBRTtRQUNWLE9BQU8sS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDMUIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQztZQUNuRCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUM7Z0JBQ2pCLEtBQUssQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLFdBQVcsR0FBRyxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLENBQUM7YUFDckUsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQixLQUFLLElBQUksU0FBUyxDQUFDO1NBQ3BCO0tBQ0Y7SUFFRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLE9BQU8sUUFBUSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0tBQ3ZDO0lBRUQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFDRCxNQUFNLENBQUMsTUFBTSxLQUFLLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLE1BQU0sRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7VGVuc29yLCBUZW5zb3IxRH0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Y29uY2F0fSBmcm9tICcuLi9jb25jYXQnO1xuaW1wb3J0IHtmaWxsfSBmcm9tICcuLi9maWxsJztcbmltcG9ydCB7b3B9IGZyb20gJy4uL29wZXJhdGlvbic7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4uL3Jlc2hhcGUnO1xuaW1wb3J0IHtzbGljZX0gZnJvbSAnLi4vc2xpY2UnO1xuaW1wb3J0IHt0ZW5zb3IyZH0gZnJvbSAnLi4vdGVuc29yMmQnO1xuXG4vKipcbiAqIEV4cGFuZHMgaW5wdXQgaW50byBmcmFtZXMgb2YgZnJhbWVMZW5ndGguXG4gKiBTbGlkZXMgYSB3aW5kb3cgc2l6ZSB3aXRoIGZyYW1lU3RlcC5cbiAqXG4gKiBgYGBqc1xuICogdGYuc2lnbmFsLmZyYW1lKFsxLCAyLCAzXSwgMiwgMSkucHJpbnQoKTtcbiAqIGBgYFxuICogQHBhcmFtIHNpZ25hbCBUaGUgaW5wdXQgdGVuc29yIHRvIGJlIGV4cGFuZGVkXG4gKiBAcGFyYW0gZnJhbWVMZW5ndGggTGVuZ3RoIG9mIGVhY2ggZnJhbWVcbiAqIEBwYXJhbSBmcmFtZVN0ZXAgVGhlIGZyYW1lIGhvcCBzaXplIGluIHNhbXBsZXMuXG4gKiBAcGFyYW0gcGFkRW5kIFdoZXRoZXIgdG8gcGFkIHRoZSBlbmQgb2Ygc2lnbmFsIHdpdGggcGFkVmFsdWUuXG4gKiBAcGFyYW0gcGFkVmFsdWUgQSBudW1iZXIgdG8gdXNlIHdoZXJlIHRoZSBpbnB1dCBzaWduYWwgZG9lc1xuICogICAgIG5vdCBleGlzdCB3aGVuIHBhZEVuZCBpcyBUcnVlLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1NpZ25hbCcsIG5hbWVzcGFjZTogJ3NpZ25hbCd9XG4gKi9cbmZ1bmN0aW9uIGZyYW1lXyhcbiAgICBzaWduYWw6IFRlbnNvcjFELCBmcmFtZUxlbmd0aDogbnVtYmVyLCBmcmFtZVN0ZXA6IG51bWJlciwgcGFkRW5kID0gZmFsc2UsXG4gICAgcGFkVmFsdWUgPSAwKTogVGVuc29yIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgY29uc3Qgb3V0cHV0OiBUZW5zb3JbXSA9IFtdO1xuICB3aGlsZSAoc3RhcnQgKyBmcmFtZUxlbmd0aCA8PSBzaWduYWwuc2l6ZSkge1xuICAgIG91dHB1dC5wdXNoKHNsaWNlKHNpZ25hbCwgc3RhcnQsIGZyYW1lTGVuZ3RoKSk7XG4gICAgc3RhcnQgKz0gZnJhbWVTdGVwO1xuICB9XG5cbiAgaWYgKHBhZEVuZCkge1xuICAgIHdoaWxlIChzdGFydCA8IHNpZ25hbC5zaXplKSB7XG4gICAgICBjb25zdCBwYWRMZW4gPSAoc3RhcnQgKyBmcmFtZUxlbmd0aCkgLSBzaWduYWwuc2l6ZTtcbiAgICAgIGNvbnN0IHBhZCA9IGNvbmNhdChbXG4gICAgICAgIHNsaWNlKHNpZ25hbCwgc3RhcnQsIGZyYW1lTGVuZ3RoIC0gcGFkTGVuKSwgZmlsbChbcGFkTGVuXSwgcGFkVmFsdWUpXG4gICAgICBdKTtcbiAgICAgIG91dHB1dC5wdXNoKHBhZCk7XG4gICAgICBzdGFydCArPSBmcmFtZVN0ZXA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGVuc29yMmQoW10sIFswLCBmcmFtZUxlbmd0aF0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc2hhcGUoY29uY2F0KG91dHB1dCksIFtvdXRwdXQubGVuZ3RoLCBmcmFtZUxlbmd0aF0pO1xufVxuZXhwb3J0IGNvbnN0IGZyYW1lID0gLyogQF9fUFVSRV9fICovIG9wKHtmcmFtZV99KTtcbiJdfQ==","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}